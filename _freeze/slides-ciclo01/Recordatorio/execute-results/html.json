{
  "hash": "0d267e4fbb88d6bc25a709147318de50",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Recordatorio Semillero R 2019-01\"\nauthor: \"Semillero R - FacCA\"\ndate: \"Junio de 2019\"\noutput:\n  ioslides_presentation:\n    css: estilo_p.css\n---\n\n\n\n\n\n# Mundo R\n\n## Atajos del teclado\n\n- `CTRL + L`: limpiar la consola.\n- `CTRL + Enter`: ejecutar código.\n- `CTRL + Shift + M`: operador de tubería (`%>%`)\n- `CTRL + Shift + K`: compilar documentos RMardkown.\n- `CTRL + Alt + i`: insetar chunk o fragmento de R en documento RMarkdown.\n- `CTRL + s`: guardar de forma rápida.\n- `CTRL + Shift + Enter`: ejecución del script completo.\n\n## Tipos de datos en R\n\n- **Numéricos:** todo dato en la escala de los reales - `numeric`.\n- **Enteros:** toda información cuantitativa sin decimales - `integer`.\n- **Lógicos:** datos dicotómicos con dos posibles resultados (TRUE o FALSE) - `logical`.\n- **Caracteres:** datos tipo texto (sin jerarquia) - `character`.\n    - **Factores:** datos tipo texto (con jerarquia). De gran utilidad para manejar variables categóricas o cualitativas - `factor`.\n- **Complejos:** datos numéricos con inclusión del número imaginario (i) - `complex`.\n\n\n## Objetos estructurados\n\n- **Vector:** los vectores tiene la característica de almacenar información de un sólo tipo (por ejemplo, sólo puedo tener numéricos o caracteres, pero no ambos) - `c()` o `vector()`.\n- **Matriz:** las matrices son arreglos de dos o más dimensiones con la misma característica de los vectores, sólo permiten almacenar información de un sólo tipo - `matrix()`.\n- **Listas:** las listas permiten almacenar información de cualquier tipo; son altamente flexibles para procesos iterativos - `list()`.\n- **Dataframe:** similar a una hoja de cálculo en excel. Constituye la materia prima (bases de datos) para cualquier proceso de Ciencia de Datos.\n- **Factores:** se definen como vectores de caracteres con estructura jerárquica (niveles) - `factor()`.\n\n## Funciones auxiliares generales 1\n\n- `str()`: devuelve la estructura interna de un objeto cualquiera.\n- `class()`: devuelve la clase atómica de un objeto, es decir, el tipo de dato.\n- `levels()`: devuelve los niveles de un factor.\n- `names()`: observar o editar los nombres de un objeto.\n- `rownames()`: observar o editar los nombres de las filas de una matriz o una base de datos (dataframe).\n- `colnames()`:observar o editar los nombres de las columnas de una matriz o una base de datos (dataframe).\n\n## Funciones auxiliares generales 2\n\n- `length()`: devuelve la longitud de un objeto. La longitud de un vector es el número de datos del mismo, sin embargo, la longitud en un dataframe o una matriz es el número de columnas o variables.\n- `dim()`: devuelve las dimensiones de una matriz o un dataframe.\n- `nrow()`: devuelve el número de filas de un objeto.\n- `ncol()`: devuelve el número de columnas de un objeto.\n\n## Funciones auxiliares numéricas 1\n\n- `summary()`: resumen numérico general. Es una función genérica.\n- `mean()`: devuelve la media. Si hay valores `NAs` se debe agregar el argumento `na.rm = TRUE` - `mean(x, na.rm = TRUE)`.\n- `median()`: devuelve la mediana. Si hay valores `NAs` se debe agregar el argumento `na.rm = TRUE` - `median(x, na.rm = TRUE)`.\n- `min()`: devuelve el valor mínimo. Si hay valores `NAs` se debe agregar el argumento `na.rm = TRUE` - `min(x, na.rm = TRUE)`.\n- `max()`: devuelve el valor máximo. Si hay valores `NAs` se debe agregar el argumento `na.rm = TRUE` - `max(x, na.rm = TRUE)`.\n- `sd()`: devuelve la desviación estándar. Si hay valores `NAs` se debe agregar el argumento `na.rm = TRUE` - `sd(x, na.rm = TRUE)`.\n\n## Funciones auxiliares numéricas 2\n\n- `var()`: devuelve la varianza. Si hay valores `NAs` se debe agregar el argumento `na.rm = TRUE` - `var(x, na.rm = TRUE)`.\n- `IQR()`: devuelve el rango intercuartílico. Si hay valores `NAs` se debe agregar el argumento `na.rm = TRUE` - `IQR(x, na.rm = TRUE)`.\n- `range()`: devuelve el rango de un objeto numérico. Si hay valores `NAs` se debe agregar el argumento `na.rm = TRUE` - `range(x, na.rm = TRUE)`.\n- `quantile()`: devuelve cuartiles, deciles o percentiles. La función requiere del valor de probabilidad para las medidas de posición (`probs = 0.25`). Si hay valores `NAs` se debe agregar el argumento `na.rm = TRUE` - `quantile(x, probs = 0.25, na.rm = TRUE)`.\n\n## Funciones para importar datos\n\n- `read.csv()`: función para importar datos en formato csv (separados por comas), donde el decimal está definido por punto (.).\n- `read.csv2()`: función para importar datos en formato csv (separados por punto y coma), donde el decimal está dado por la com (,).\n- `read.table()`: función para importar datos en formato txt (texto plano o sin formato), donde el decimal está dado por el punto (.)\n- **Datos en formato office:** para importar datos en formato .xls o .xlsx es necesario instalar la biblioteca `readxl` e implementar la función `read_xlsx()` o `read_xls`.\n- `load()`: función que permite importar información en formato `.Rdata` (formato específico del lenguaje R).\n\n## Funciones para exportar datos\n\n- `write.csv()`: función que permite exportar datos en formato .csv (separados por comas) y el decimal está definido por el punto (.).\n- `write.csv2()`: función que permite exportar datos en formato .csv (separados por punto y comas) y el decimal está definido por la coma (,).\n- `write.table()`: función que permite exportar datos en formato .txt (texto plano o sin formato) y el decimal está definido por el punto (.).\n- **Datos en formato office:** para exportar datos en formato .xls o .xlsx es necesario instalar las bibliotecas `writexl` o `WriteXLS` e implementar las funciones `write_xlsx()` o `WriteXLS()`, respectivamente.\n- **save()**: función para exportar datos en formato .Rdata. **Nota:** no olvidar que la función `save` permite diferentes niveles de compresión a través del argumento `compress.level`.\n\n# Tidyverse\n\n## Introducción\n\n- El `tidyverse` no es una biblioteca en sí misma, es un grupo de bibliotecas o componentes que conforman el paradigma de programación de `datos ordenados` (tidydata).\n- Los datos ordenados tienen las siguientes tres características:\n    - Cada fila es una observación, individuo o registro.\n    - Cada columna es una variable.\n    - Cada celda es un dato.\n- Algunas de las bibliotecas que componen el `tidyverse` son: `dplyr`, `tidyr`, `ggplot2`.\n- El `tidyverse` posee la particularidad de concatenar procesos a través del operador de tubería (`%>%`).\n\n## Manejo de datos con `dplyr`\n\n- `filter()`: filtrar filas bajo una o más condiciones.\n- `slice()`: seleccionar filas basado en la indexación (posición).\n- `arrange()`: ordenar filas en función de algún criterio. Por defecto la función ordena las filas de manera ascendente, sin embargo, con el argumento `desc` es posible cambiar dicho orden.\n- `select()`: seleccionar columnas por nombre.\n- `rename()`: editar nombres de variables.\n- `mutate()`: editar o crear nuevas variables en función de las existentes.\n- `group_by()`: permite conformar grupos \"latentes\" para resúmenes numéricos. La gran mayoría de veces está acompañada de la función `summarise()`.\n- `summarise()`: permite obtener resúmenes numéricos para variables de interés (agrupadas o sin agrupar).\n\n## Conversión de formatos con `tidyr`\n\n- La biblioteca `tidyr` permite conversiones de formatos. Es de utilidad para pasar de formatos largos a achos o viceversa.\n- `gather()`: conversión de formato ancho a largo, es decir, que permite disminuir la dimensialidad de los datos (reducir el número de variables).\n- `spread()`: conversión de formato largo a ancho, es decir, que permite aumentar la dimensionalidad de los datos (aumentar el número de columnas).\n- <rojo>Característica principal:</rojo> siempre cualquiera de las dos funciones debe contener una llave (`key`) y un valor (`value`) asociado a dicha llave.\n- Las funciones `separate()` y `unite()` son de utilidad para separar o unir columnas.\n\n## Visualización con `ggplot2`\n\n- `ggplot2` permite visualizar gráficos con instrucciones dadas por capas.\n- <rojo>Sintaxis principal:</rojo>\n    - **1era capa:** `ggplot(data = datos, mapping = aes(x, y))`\n    - **2da capa:** asignación de objetos geométricos con las funciones que tiene el prefijo `geom_`:\n        - `geom_boxplot()`, `geom_histogram()`, `geom_density()`,\n        `geom_point()`, `geom_bar()`, `geom_col`, entre otras.\n    - **3ra capa:** asignación de rótulos. Es posible hacerlo con la función `labs()`.\n    - Cada capa se adiciona con el símbolo más (+).\n\n    \n# Estilo con css\n\n## Pasos a seguir...\n\n1. Crear un archivo con formato .css (darle un nombre) en el mismo directorio de trabajo.\n2. Editar o incorporar clases para formatos específicos de texto.\n3. Dar nombre a la clase en css (puede ser cualquiera) seguido de las llaves `{}`. Dentro de las llaves se indican los formatos específicos; en este caso, el color. `rojo {color: red;}`\n4. Incorporar en los metadatos (con la opción css) el archivo (.css) que determina el estilo del documento.\n5. Hacer uso de la clase específica de la siguiente manera: `<clase>Texto</clase>`. <rojo>Texto en color rojo</rojo>\n6. [Mayor información en W3Schools.](https://www.w3schools.com/)\n\n\n\n\n\n\n\n\n\n\n\n\n\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}